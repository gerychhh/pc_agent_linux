commands:
- id: CMD_OPEN_URL
  intents:
  - открой сайт *
  - открой url *
  - open url *
  - open website *
  description_short: Открывает ссылку в браузере (xdg-open).
  params:
  - name: url
    from_user: true
  execute:
    lang: bash
    script: 'set -e

      url="{{url}}"

      xdg-open "$url" >/dev/null 2>&1 || true

      echo "OK"

      '
  verify:
    lang: python
    script: print('OK')
  success:
    type: custom
- id: CMD_OPEN_FOLDER
  intents:
  - открой папку *
  - open folder *
  - open directory *
  description_short: Открывает папку в файловом менеджере.
  params:
  - name: path
    from_user: true
  execute:
    lang: bash
    script: 'set -e

      p="{{path}}"

      xdg-open "$p" >/dev/null 2>&1 || true

      echo "OK"

      '
  verify:
    lang: python
    script: print('OK')
  success:
    type: custom
- id: CMD_LIST_HOME
  intents:
  - что в домашней папке
  - покажи домашнюю папку
  - list home
  - ls home
  description_short: Показывает список файлов в ~.
  execute:
    lang: bash
    script: 'ls -lah ~ | head -n 200

      '
  verify:
    lang: python
    script: print('OK')
  success:
    type: custom
- id: CMD_FIND_FILE
  intents:
  - найди файл *
  - find file *
  - search file *
  - поиск файла *
  description_short: Ищет файлы по имени в домашней папке (быстро, без sudo).
  params:
  - name: name
    from_user: true
  execute:
    lang: bash
    script: 'set -e

      n="{{name}}"

      find ~ -maxdepth 5 -iname "*${n}*" 2>/dev/null | head -n 50

      '
  verify:
    lang: python
    script: print('OK')
  success:
    type: custom
- id: CMD_LIST_PROCESSES
  intents:
  - какие процессы
  - список процессов
  - list processes
  - ps
  description_short: Показывает топ процессов по CPU.
  execute:
    lang: bash
    script: 'ps -eo pid,comm,%cpu,%mem --sort=-%cpu | head -n 25

      '
  verify:
    lang: python
    script: print('OK')
  success:
    type: custom
- id: CMD_KILL_PROCESS
  intents:
  - убей процесс *
  - закрой процесс *
  - kill process *
  description_short: Завершает процесс по имени (pkill -f).
  params:
  - name: name
    from_user: true
  execute:
    lang: bash
    script: 'set -e

      n="{{name}}"

      pkill -f "$n" || true

      echo "OK"

      '
  verify:
    lang: python
    script: print('OK')
  success:
    type: custom
- id: CMD_OPEN_APP
  intents:
  - открой приложение *
  - запусти *
  - open app *
  - launch *
  description_short: Пытается запустить приложение по имени (через gio/gtk-launch/command).
  params:
  - name: app
    from_user: true
  execute:
    lang: python
    script: |
      import os
      import re
      import shlex
      import shutil
      import subprocess
      import sys
      from difflib import SequenceMatcher
      from pathlib import Path

      query_raw = """{{app}}""".strip()
      if not query_raw:
          print("App not found: (empty)", file=sys.stderr)
          sys.exit(1)

      def _norm(text: str) -> str:
          text = (text or "").lower()
          text = text.replace("_", " ").replace("-", " ")
          text = re.sub(r"[^0-9a-zа-яё]+", " ", text, flags=re.IGNORECASE)
          text = re.sub(r"\s+", " ", text).strip()
          return text

      def _strip_noise(text: str) -> str:
          text = _norm(text)
          # remove common filler words
          text = re.sub(r"\b(на|в|у|мой|мои|моем|моём|пк|компьютере|ноутбуке|"
                        r"on|in|my|pc|computer|laptop)\b", " ", text, flags=re.IGNORECASE)
          text = re.sub(r"\s+", " ", text).strip()
          return text

      def _score(query: str, candidate: str) -> float:
          if not candidate:
              return 0.0
          if query and query in candidate:
              return 1.0
          return SequenceMatcher(None, query, candidate).ratio()

      def _clean_exec(exec_line: str) -> str:
          if not exec_line:
              return ""
          # drop desktop placeholders like %U, %f, etc.
          cleaned = re.sub(r"%[fFuUdDnNickvm]", "", exec_line)
          cleaned = cleaned.replace("%%", "%")
          return cleaned.strip()

      def _parse_desktop(path: Path) -> dict[str, str] | None:
          name = ""
          name_ru = ""
          generic = ""
          exec_line = ""
          nodisplay = False
          hidden = False
          in_entry = False
          try:
              with path.open("r", encoding="utf-8", errors="ignore") as fh:
                  for raw in fh:
                      line = raw.strip()
                      if not line or line.startswith("#"):
                          continue
                      if line.startswith("["):
                          in_entry = (line == "[Desktop Entry]")
                          continue
                      if not in_entry:
                          continue
                      if line.startswith("NoDisplay="):
                          nodisplay = line.split("=", 1)[1].strip().lower() == "true"
                      elif line.startswith("Hidden="):
                          hidden = line.split("=", 1)[1].strip().lower() == "true"
                      elif line.startswith("Name[ru") and not name_ru:
                          name_ru = line.split("=", 1)[1].strip()
                      elif line.startswith("Name=") and not name:
                          name = line.split("=", 1)[1].strip()
                      elif line.startswith("GenericName=") and not generic:
                          generic = line.split("=", 1)[1].strip()
                      elif line.startswith("Exec=") and not exec_line:
                          exec_line = line.split("=", 1)[1].strip()
          except Exception:
              return None
          if hidden or nodisplay:
              return None
          desktop_id = path.stem
          display = name_ru or name or generic or desktop_id
          return {
              "id": desktop_id,
              "name": display,
              "exec": exec_line,
              "path": str(path),
          }

      def _collect_desktops() -> list[dict[str, str]]:
          dirs = [
              Path.home() / ".local/share/applications",
              Path("/usr/share/applications"),
              Path("/usr/local/share/applications"),
              Path.home() / ".local/share/flatpak/exports/share/applications",
              Path("/var/lib/flatpak/exports/share/applications"),
          ]
          out: list[dict[str, str]] = []
          seen: set[str] = set()
          for d in dirs:
              if not d.exists():
                  continue
              for path in d.glob("*.desktop"):
                  if path.name in seen:
                      continue
                  entry = _parse_desktop(path)
                  if not entry:
                      continue
                  seen.add(path.name)
                  out.append(entry)
          return out

      def _launch(entry: dict[str, str]) -> tuple[bool, str]:
          desktop_id = entry.get("id") or ""
          exec_line = entry.get("exec") or ""
          if desktop_id and shutil.which("gtk-launch"):
              subprocess.Popen(["gtk-launch", desktop_id], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
              return True, "gtk-launch"
          exec_cmd = _clean_exec(exec_line)
          if exec_cmd:
              args = shlex.split(exec_cmd)
              subprocess.Popen(args, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
              return True, "exec"
          return False, "no-launcher"

      query = _strip_noise(query_raw)
      if not query:
          query = _norm(query_raw)

      apps = _collect_desktops()
      best = None
      best_score = 0.0
      for app in apps:
          candidates = [
              _norm(app.get("name", "")),
              _norm(app.get("id", "")),
              _norm(app.get("exec", "")),
          ]
          score = 0.0
          for cand in candidates:
              score = max(score, _score(query, cand))
          qt = set(query.split())
          ct = set(candidates[0].split())
          if qt:
              score = max(score, len(qt & ct) / max(len(qt), 1))
          if score > best_score:
              best_score = score
              best = app

      if not best or best_score < 0.55:
          print(f"App not found: {query_raw}", file=sys.stderr)
          sys.exit(1)

      ok, method = _launch(best)
      if not ok:
          print(f"App not found: {query_raw}", file=sys.stderr)
          sys.exit(1)

      print("OK")
  verify:
    lang: python
    script: print('OK')
  success:
    type: custom
- id: CMD_OPEN_FILE
  intents:
  - открой файл *
  - open file *
  description_short: Открывает файл через xdg-open.
  params:
  - name: path
    from_user: true
  execute:
    lang: bash
    script: 'set -e

      p="{{path}}"

      xdg-open "$p" >/dev/null 2>&1 || true

      echo "OK"'
  verify:
    lang: python
    script: print('OK')
  success:
    type: custom
- id: CMD_SEARCH_WEB
  intents:
  - поиск *
  - найди в интернете *
  - search web *
  - google *
  description_short: Открывает поиск в браузере (Google).
  params:
  - name: query
    from_user: true
  execute:
    lang: bash
    script: 'set -e

      q="{{query}}"

      url="$(python3 - "$q" <<''PY''

      import sys, urllib.parse

      q=sys.argv[1]

      print("https://www.google.com/search?q=" + urllib.parse.quote_plus(q))

      PY

      )"

      xdg-open "$url" >/dev/null 2>&1 || true

      echo "OK"

      '
  verify:
    lang: python
    script: print('OK')
  success:
    type: custom
- id: CMD_DISK_INFO
  intents:
  - сколько места на диске
  - память на диске
  - disk usage
  - df
  description_short: Показывает свободное место и разделы (df/lsblk).
  execute:
    lang: bash
    script: 'df -h | head -n 80

      echo

      lsblk -f | head -n 80'
  verify:
    lang: python
    script: print('OK')
  success:
    type: custom
- id: CMD_GPU_INFO
  intents:
  - покажи gpu
  - покажи видеокарту
  - gpu info
  - nvidia
  description_short: Показывает информацию о GPU (nvidia-smi если есть).
  execute:
    lang: bash
    script: "if command -v nvidia-smi >/dev/null 2>&1; then\n  nvidia-smi\nelse\n\
      \  lspci | grep -Ei \"vga|3d|display\" || true\nfi"
  verify:
    lang: python
    script: print('OK')
  success:
    type: custom
- id: CMD_NET_INFO
  intents:
  - сетевые интерфейсы
  - ip адрес
  - network info
  - ip a
  description_short: Показывает IP/интерфейсы (ip).
  execute:
    lang: bash
    script: 'ip -br a

      ip route | head -n 50'
  verify:
    lang: python
    script: print('OK')
  success:
    type: custom
- id: CMD_OPEN_CODE
  intents:
  - открой в vscode *
  - open in vscode *
  - code *
  description_short: Открывает путь в VS Code (если установлен).
  params:
  - name: path
    from_user: true
  execute:
    lang: bash
    script: "set -e\np=\"{{path}}\"\nif command -v code >/dev/null 2>&1; then\n  code\
      \ \"$p\" >/dev/null 2>&1 || true\nelse\n  xdg-open \"$p\" >/dev/null 2>&1 ||\
      \ true\nfi\necho \"OK\""
  verify:
    lang: python
    script: print('OK')
  success:
    type: custom
- id: CMD_GIT_STATUS
  intents:
  - git status *
  - статус гита *
  - проверь git *
  description_short: Показывает git status в папке.
  params:
  - name: path
    from_user: true
  execute:
    lang: bash
    script: 'set -e

      cd "{{path}}"

      git status -sb'
  verify:
    lang: python
    script: print('OK')
  success:
    type: custom
- id: CMD_GIT_PULL
  intents:
  - git pull *
  - обнови репозиторий *
  - git update *
  description_short: git pull --ff-only в папке.
  params:
  - name: path
    from_user: true
  execute:
    lang: bash
    script: 'set -e

      cd "{{path}}"

      git pull --ff-only'
  verify:
    lang: python
    script: print('OK')
  success:
    type: custom
- id: CMD_FIND_TEXT
  intents:
  - найди текст * в *
  - search text * in *
  - grep * in *
  description_short: Ищет текст в папке (rg или grep).
  params:
  - name: text
    from_user: true
  - name: path
    from_user: true
  execute:
    lang: bash
    script: "set -e\nt=\"{{text}}\"\np=\"{{path}}\"\nif command -v rg >/dev/null 2>&1;\
      \ then\n  rg --line-number --no-heading --max-columns 200 \"$t\" \"$p\" | head\
      \ -n 50 || true\nelse\n  grep -RIn --exclude-dir .git -- \"$t\" \"$p\" 2>/dev/null\
      \ | head -n 50 || true\nfi\necho \"OK\""
  verify:
    lang: python
    script: print('OK')
  success:
    type: custom
- id: CMD_VOLUME_UP
  intents:
  - громче
  - прибавь звук
  - увеличь громкость
  - volume up
  - increase volume
  - make it louder
  - звук громче *
  description_short: Увеличивает громкость (pactl/amixer).
  params:
  - name: step
    from_user: true
    optional: true
  execute:
    lang: bash
    script: "set -e\nstep=\"{{step}}\"\nstep=\"$(echo \"$step\" | grep -Eo '[0-9]+'\
      \ | head -n1 || true)\"\nif [ -z \"$step\" ] || ! echo \"$step\" | grep -Eq\
      \ '^[0-9]+$'; then step=5; fi\nif command -v pactl >/dev/null 2>&1; then\n \
      \ pactl set-sink-volume @DEFAULT_SINK@ +${step}%\nelif command -v amixer >/dev/null\
      \ 2>&1; then\n  amixer -D pulse sset Master ${step}%+ >/dev/null\nelse\n  echo\
      \ \"No pactl/amixer\" >&2; exit 1\nfi\necho \"OK\"\n"
  verify:
    lang: bash
    script: 'true'
  success:
    type: custom
- id: CMD_VOLUME_DOWN
  intents:
  - тише
  - убавь звук
  - уменьши громкость
  - volume down
  - decrease volume
  - make it quieter
  - звук тише *
  description_short: Уменьшает громкость (pactl/amixer).
  params:
  - name: step
    from_user: true
    optional: true
  execute:
    lang: bash
    script: "set -e\nstep=\"{{step}}\"\nstep=\"$(echo \"$step\" | grep -Eo '[0-9]+'\
      \ | head -n1 || true)\"\nif [ -z \"$step\" ] || ! echo \"$step\" | grep -Eq\
      \ '^[0-9]+$'; then step=5; fi\nif command -v pactl >/dev/null 2>&1; then\n \
      \ pactl set-sink-volume @DEFAULT_SINK@ -${step}%\nelif command -v amixer >/dev/null\
      \ 2>&1; then\n  amixer -D pulse sset Master ${step}%- >/dev/null\nelse\n  echo\
      \ \"No pactl/amixer\" >&2; exit 1\nfi\necho \"OK\"\n"
  verify:
    lang: bash
    script: 'true'
  success:
    type: custom
- id: CMD_VOLUME_MUTE
  intents:
  - выключи звук
  - mute
  - mute volume
  - звук выкл
  - без звука
  - поставь на беззвучный
  - включи звук
  - unmute
  description_short: Переключает mute (pactl/amixer).
  params: []
  execute:
    lang: bash
    script: "set -e\nif command -v pactl >/dev/null 2>&1; then\n  pactl set-sink-mute\
      \ @DEFAULT_SINK@ toggle\nelif command -v amixer >/dev/null 2>&1; then\n  amixer\
      \ -D pulse sset Master toggle >/dev/null\nelse\n  echo \"No pactl/amixer\" >&2;\
      \ exit 1\nfi\necho \"OK\"\n"
  verify:
    lang: bash
    script: 'true'
  success:
    type: custom
- id: CMD_MEDIA_PLAY_PAUSE
  intents:
  - пауза
  - play pause
  - play/pause
  - переключи воспроизведение
  - останови музыку
  - продолжи музыку
  description_short: Play/Pause для активного плеера (playerctl).
  params: []
  execute:
    lang: bash
    script: "set -e\nif command -v playerctl >/dev/null 2>&1; then\n  playerctl play-pause\n\
      \  echo \"OK\"\nelse\n  echo \"playerctl not installed\" >&2\n  exit 1\nfi\n"
  verify:
    lang: bash
    script: 'true'
  success:
    type: custom
- id: CMD_WIFI_STATUS
  intents:
  - вайфай статус
  - wifi status
  - статус wifi
  - интернет статус
  - wifi on?
  - wifi off?
  description_short: Показывает состояние Wi‑Fi (nmcli).
  params: []
  execute:
    lang: bash
    script: "set -e\nif command -v nmcli >/dev/null 2>&1; then\n  nmcli -t -f WIFI\
      \ g\nelse\n  echo \"nmcli not installed\" >&2; exit 1\nfi\n"
  verify:
    lang: bash
    script: 'true'
  success:
    type: custom
- id: CMD_WIFI_ON
  intents:
  - включи вайфай
  - wifi on
  - enable wifi
  - включи wifi
  description_short: Включает Wi‑Fi (nmcli).
  params: []
  execute:
    lang: bash
    script: "set -e\nif command -v nmcli >/dev/null 2>&1; then\n  nmcli radio wifi\
      \ on\n  echo \"OK\"\nelse\n  echo \"nmcli not installed\" >&2; exit 1\nfi\n"
  verify:
    lang: bash
    script: 'true'
  success:
    type: custom
- id: CMD_WIFI_OFF
  intents:
  - выключи вайфай
  - wifi off
  - disable wifi
  - выключи wifi
  description_short: Выключает Wi‑Fi (nmcli).
  params: []
  execute:
    lang: bash
    script: "set -e\nif command -v nmcli >/dev/null 2>&1; then\n  nmcli radio wifi\
      \ off\n  echo \"OK\"\nelse\n  echo \"nmcli not installed\" >&2; exit 1\nfi\n"
  verify:
    lang: bash
    script: 'true'
  success:
    type: custom
- id: CMD_SCREENSHOT_AREA
  intents:
  - сделай скриншот
  - скриншот
  - screenshot
  - screenshot area
  - скрин области
  - снимок экрана
  - сделай скрин области
  description_short: Скриншот выделенной области (flameshot/gnome-screenshot/grim+slurp).
  params: []
  execute:
    lang: bash
    script: "set -e\ndir=\"$HOME/Pictures/Screenshots\"\nmkdir -p \"$dir\"\nts=\"\
      $(date +%Y%m%d_%H%M%S)\"\nfile=\"$dir/screen_${ts}.png\"\n\nif command -v flameshot\
      \ >/dev/null 2>&1; then\n  flameshot gui -p \"$dir\" >/dev/null 2>&1 || true\n\
      \  echo \"OK\"\n  exit 0\nfi\n\nif command -v gnome-screenshot >/dev/null 2>&1;\
      \ then\n  gnome-screenshot -a -f \"$file\"\n  echo \"SAVED: $file\"\n  exit\
      \ 0\nfi\n\nif command -v grim >/dev/null 2>&1 && command -v slurp >/dev/null\
      \ 2>&1; then\n  grim -g \"$(slurp)\" \"$file\"\n  echo \"SAVED: $file\"\n  exit\
      \ 0\nfi\n\necho \"No screenshot tool found (flameshot/gnome-screenshot/grim+slurp)\"\
      \ >&2\nexit 1\n"
  verify:
    lang: bash
    script: 'true'
  success:
    type: custom
